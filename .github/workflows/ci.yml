name: Continuous Integration

on:
  push:
    branches:
      - main
  pull_request:
    branches:
      - main
  schedule:
    # Weekly full-profile runtime validation (Mondays at 09:00 UTC)
    - cron: '0 9 * * 1'
  workflow_dispatch:
    inputs:
      run_full_profile_smoke:
        description: 'Run full chat-profile smoke (includes local LLM/vector dependencies)'
        required: false
        default: false
        type: boolean

jobs:
  changes:
    name: Detect Changed Surfaces
    runs-on: ubuntu-latest
    outputs:
      web: ${{ steps.detector.outputs.web }}
      chat: ${{ steps.detector.outputs.chat }}
      runtime: ${{ steps.detector.outputs.runtime }}
      docs: ${{ steps.detector.outputs.docs }}
      unknown: ${{ steps.detector.outputs.unknown }}
      none: ${{ steps.detector.outputs.none }}
      targets: ${{ steps.detector.outputs.targets }}
      base: ${{ steps.detector.outputs.base }}
      head: ${{ steps.detector.outputs.head }}
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Detect scoped changes
        id: detector
        shell: bash
        run: |
          set -euo pipefail

          if [[ "${{ github.event_name }}" == "workflow_dispatch" ]]; then
            echo "base=" >> "$GITHUB_OUTPUT"
            echo "head=${{ github.sha }}" >> "$GITHUB_OUTPUT"
            echo "runtime=true" >> "$GITHUB_OUTPUT"
            echo "web=true" >> "$GITHUB_OUTPUT"
            echo "chat=true" >> "$GITHUB_OUTPUT"
            echo "docs=true" >> "$GITHUB_OUTPUT"
            echo "unknown=false" >> "$GITHUB_OUTPUT"
            echo "none=false" >> "$GITHUB_OUTPUT"
            echo "targets=toolchain-doctor env-contract-check test-scripts quick-ci-web quick-ci-chat docs-check" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [[ "${{ github.event_name }}" == "schedule" ]]; then
            echo "base=" >> "$GITHUB_OUTPUT"
            echo "head=${{ github.sha }}" >> "$GITHUB_OUTPUT"
            echo "runtime=false" >> "$GITHUB_OUTPUT"
            echo "web=false" >> "$GITHUB_OUTPUT"
            echo "chat=false" >> "$GITHUB_OUTPUT"
            echo "docs=false" >> "$GITHUB_OUTPUT"
            echo "unknown=false" >> "$GITHUB_OUTPUT"
            echo "none=true" >> "$GITHUB_OUTPUT"
            echo "targets=" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          if [[ "${{ github.event_name }}" == "pull_request" ]]; then
            BASE_SHA="${{ github.event.pull_request.base.sha }}"
          else
            BASE_SHA="${{ github.event.before }}"
          fi
          HEAD_SHA="${{ github.sha }}"

          echo "base=$BASE_SHA" >> "$GITHUB_OUTPUT"
          echo "head=$HEAD_SHA" >> "$GITHUB_OUTPUT"

          if [[ -z "$BASE_SHA" || "$BASE_SHA" == "0000000000000000000000000000000000000000" ]]; then
            echo "runtime=true" >> "$GITHUB_OUTPUT"
            echo "web=true" >> "$GITHUB_OUTPUT"
            echo "chat=true" >> "$GITHUB_OUTPUT"
            echo "docs=true" >> "$GITHUB_OUTPUT"
            echo "unknown=false" >> "$GITHUB_OUTPUT"
            echo "none=false" >> "$GITHUB_OUTPUT"
            echo "targets=toolchain-doctor env-contract-check test-scripts quick-ci-web quick-ci-chat docs-check" >> "$GITHUB_OUTPUT"
            exit 0
          fi

          python scripts/detect_changed_surfaces.py \
            --base "$BASE_SHA" \
            --head "$HEAD_SHA" \
            --github-output "$GITHUB_OUTPUT"

  env-contract:
    name: Env Contract Drift Check
    needs: changes
    if: ${{ github.event_name != 'push' && needs.changes.outputs.runtime == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Validate env contract
        run: make env-contract-check PYTHON=python

  script-tests:
    name: Script Guardrail Tests
    needs: changes
    if: ${{ github.event_name != 'push' && needs.changes.outputs.runtime == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Run script tests
        run: make test-scripts PYTHON=python

  docs-ci:
    name: Documentation Link Checks
    needs: changes
    if: ${{ github.event_name != 'push' && (needs.changes.outputs.docs == 'true' || needs.changes.outputs.runtime == 'true') }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Verify docs links
        run: make docs-check PYTHON=python

  web-ci:
    name: Web App CI
    needs: changes
    if: ${{ github.event_name != 'push' && (needs.changes.outputs.web == 'true' || needs.changes.outputs.runtime == 'true') }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'
          cache-dependency-path: apps/web/package-lock.json

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Toolchain preflight
        run: TOOLCHAIN_CHECK_ALLOW_NON_MISE=1 make toolchain-doctor PYTHON=python

      - name: Install dependencies
        env:
          HUSKY: 0
        run: make -C apps/web setup

      - name: Run web checks
        run: npm run ci:web

  chat-ci:
    name: Chat Service CI
    needs: changes
    if: ${{ github.event_name != 'push' && (needs.changes.outputs.chat == 'true' || needs.changes.outputs.runtime == 'true') }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Toolchain preflight
        run: TOOLCHAIN_CHECK_ALLOW_NON_MISE=1 make toolchain-doctor PYTHON=python

      - name: Install dependencies
        run: make -C services/chat setup

      - name: Generate Prisma Client (Python)
        run: |
          prisma-client-py generate --schema=${{ github.workspace }}/apps/web/prisma/schema.prisma

      - name: Run unit tests
        run: npm run ci:chat
        env:
          PROJECT_ID: local-project
          REGION: us-central1

  integration-e2e:
    name: Integration E2E Smoke
    needs: changes
    if: ${{ github.event_name != 'push' && (needs.changes.outputs.web == 'true' || needs.changes.outputs.chat == 'true' || needs.changes.outputs.runtime == 'true') }}
    runs-on: ubuntu-latest
    timeout-minutes: 35
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Restore lite metrics history cache
        id: restore_lite_history
        uses: actions/cache/restore@v4
        with:
          path: .ci-metrics
          key: e2e-metrics-lite-${{ github.ref_name }}-${{ github.run_id }}-${{ github.run_attempt }}
          restore-keys: |
            e2e-metrics-lite-${{ github.ref_name }}-

      - name: Build web image (cached)
        uses: docker/build-push-action@v6
        with:
          context: .
          file: Dockerfile
          load: true
          tags: contoso-web:latest
          cache-from: type=gha,scope=contoso-web
          cache-to: type=gha,mode=max,scope=contoso-web

      - name: Build chat image (cached, minimal profile)
        uses: docker/build-push-action@v6
        with:
          context: .
          file: services/chat/Dockerfile
          load: true
          tags: contoso-chat:latest
          build-args: |
            INSTALL_LOCAL_STACK=0
          cache-from: type=gha,scope=contoso-chat
          cache-to: type=gha,mode=max,scope=contoso-chat

      - name: Run e2e smoke
        id: run_smoke
        env:
          KEEP_STACK: '1'
          DOCKER_BUILDKIT: '1'
          COMPOSE_DOCKER_CLI_BUILD: '1'
          E2E_SMOKE_TIMEOUT: '300'
        run: |
          start_epoch="$(date +%s)"
          make e2e-smoke-lite \
            PYTHON=python \
            KEEP_STACK=1 \
            E2E_SMOKE_TIMEOUT="${E2E_SMOKE_TIMEOUT}" \
            CHAT_INSTALL_LOCAL_STACK=0 \
            E2E_COMPOSE_UP_FLAGS="-d --force-recreate --quiet-pull"
          end_epoch="$(date +%s)"
          echo "duration_seconds=$((end_epoch-start_epoch))" >> "$GITHUB_OUTPUT"

      - name: Capture dependency health snapshot
        id: dependencies_health_lite
        if: always()
        env:
          OUT_FILE: e2e-dependencies-health.json
          PROFILE_LABEL: Lite Profile
        run: |
          python - <<'PY'
          import json
          import os
          import urllib.error
          import urllib.request

          out_file = os.environ["OUT_FILE"]
          profile_label = os.environ["PROFILE_LABEL"]
          url = "http://127.0.0.1:8000/health/dependencies"

          payload = None
          capture_error = None
          http_status = None
          try:
              with urllib.request.urlopen(url, timeout=8) as response:
                  http_status = response.getcode()
                  raw = response.read().decode("utf-8", errors="replace")
              payload = json.loads(raw) if raw else None
          except (urllib.error.URLError, TimeoutError, ValueError, json.JSONDecodeError) as exc:
              capture_error = str(exc)

          if not isinstance(payload, dict):
              payload = {
                  "status": "unavailable",
                  "error": capture_error or "Unable to parse dependency health response.",
              }
          if http_status is not None:
              payload.setdefault("http_status", http_status)
          if capture_error:
              payload.setdefault("capture_error", capture_error)

          with open(out_file, "w", encoding="utf-8") as handle:
              json.dump(payload, handle, indent=2, sort_keys=True)
              handle.write("\n")

          db_connected = payload.get("database", {}).get("connected")
          local_provider = payload.get("local_provider")
          local_provider_ready = (
              local_provider.get("ready")
              if isinstance(local_provider, dict)
              else None
          )
          local_provider_enabled = (
              local_provider.get("enabled")
              if isinstance(local_provider, dict)
              else None
          )

          with open(os.environ["GITHUB_STEP_SUMMARY"], "a", encoding="utf-8") as summary:
              summary.write(f"### Dependency Health Snapshot ({profile_label})\n")
              summary.write(f"- status: `{payload.get('status', 'unknown')}`\n")
              summary.write(f"- database.connected: `{db_connected}`\n")
              summary.write(f"- local_provider.enabled: `{local_provider_enabled}`\n")
              summary.write(f"- local_provider.ready: `{local_provider_ready}`\n")
          PY

      - name: Capture compose logs
        if: always()
        run: |
          docker compose ps || true
          docker compose logs --no-color db chat web > e2e-compose.log || true

      - name: Capture e2e metrics
        id: metrics
        if: always()
        run: |
          duration="${{ steps.run_smoke.outputs.duration_seconds }}"
          [ -z "$duration" ] && duration="unknown"
          chat_size="$(docker image inspect contoso-chat:latest --format '{{.Size}}' 2>/dev/null || echo 0)"
          web_size="$(docker image inspect contoso-web:latest --format '{{.Size}}' 2>/dev/null || echo 0)"
          max_duration=420
          max_chat_size=2500000000
          max_web_size=1500000000
          budget_failed=0
          warnings=()
          if [ "$duration" != "unknown" ] && [ "$duration" -gt "$max_duration" ]; then
            warnings+=("duration_above_budget")
            budget_failed=1
          fi
          if [ "$chat_size" -gt "$max_chat_size" ]; then
            warnings+=("chat_image_above_budget")
            budget_failed=1
          fi
          if [ "$web_size" -gt "$max_web_size" ]; then
            warnings+=("web_image_above_budget")
            budget_failed=1
          fi
          {
            echo "duration_seconds=$duration"
            echo "max_duration_seconds=$max_duration"
            echo "chat_image_bytes=$chat_size"
            echo "max_chat_image_bytes=$max_chat_size"
            echo "web_image_bytes=$web_size"
            echo "max_web_image_bytes=$max_web_size"
            for warning in "${warnings[@]}"; do
              echo "warning=$warning"
            done
          } | tee e2e-metrics.txt
          echo "budget_failed=$budget_failed" >> "$GITHUB_OUTPUT"

      - name: Analyze e2e metrics trend
        id: analyze_metrics
        if: always()
        run: |
          mkdir -p .ci-metrics
          python scripts/ci_smoke_metrics.py \
            --profile lite \
            --metrics-file e2e-metrics.txt \
            --history-file .ci-metrics/lite-history.json \
            --summary-file e2e-metrics-summary.md \
            --run-id "${{ github.run_id }}" \
            --sha "${{ github.sha }}" \
            --status "${{ steps.run_smoke.outcome }}" \
            --budget-failed "${{ steps.metrics.outputs.budget_failed }}" \
            --github-output "$GITHUB_OUTPUT"
          cat e2e-metrics-summary.md >> "$GITHUB_STEP_SUMMARY"

      - name: Flag e2e regression signal
        if: ${{ always() && steps.analyze_metrics.outputs.regression_detected == 'true' }}
        run: echo "::warning::E2E lite profile regression signal detected vs previous successful baseline."

      - name: Enforce e2e budgets
        if: ${{ always() && steps.run_smoke.outcome == 'success' }}
        run: |
          if [ "${{ steps.metrics.outputs.budget_failed }}" = "1" ]; then
            echo "::error::E2E smoke exceeded duration/image-size budget. See e2e-metrics.txt artifact."
            exit 1
          fi

      - name: Upload e2e logs
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: e2e-compose-logs-${{ github.run_id }}
          path: |
            e2e-compose.log
            e2e-metrics.txt
            e2e-metrics-summary.md
            e2e-dependencies-health.json
            .ci-metrics/lite-history.json
          if-no-files-found: warn

      - name: Save lite metrics history cache
        if: always()
        uses: actions/cache/save@v4
        with:
          path: .ci-metrics
          key: e2e-metrics-lite-${{ github.ref_name }}-${{ github.run_id }}-${{ github.run_attempt }}

      - name: Teardown e2e stack
        if: always()
        run: docker compose down --volumes --remove-orphans

  integration-e2e-full-profile:
    name: Integration E2E Smoke (Full Chat Profile)
    permissions:
      contents: read
      issues: write
    if: ${{ github.event_name == 'schedule' || (github.event_name == 'workflow_dispatch' && github.event.inputs.run_full_profile_smoke == 'true') }}
    runs-on: ubuntu-latest
    timeout-minutes: 55
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'

      - name: Set up Docker Buildx
        uses: docker/setup-buildx-action@v3

      - name: Restore full metrics history cache
        id: restore_full_history
        uses: actions/cache/restore@v4
        with:
          path: .ci-metrics
          key: e2e-metrics-full-${{ github.ref_name }}-${{ github.run_id }}-${{ github.run_attempt }}
          restore-keys: |
            e2e-metrics-full-${{ github.ref_name }}-

      - name: Build web image (cached)
        uses: docker/build-push-action@v6
        with:
          context: .
          file: Dockerfile
          load: true
          tags: contoso-web:latest
          cache-from: type=gha,scope=contoso-web
          cache-to: type=gha,mode=max,scope=contoso-web

      - name: Build chat image (cached, full profile)
        uses: docker/build-push-action@v6
        with:
          context: .
          file: services/chat/Dockerfile
          load: true
          tags: contoso-chat:latest
          build-args: |
            INSTALL_LOCAL_STACK=1
          cache-from: type=gha,scope=contoso-chat
          cache-to: type=gha,mode=max,scope=contoso-chat

      - name: Run e2e smoke (full profile)
        id: run_smoke_full
        env:
          KEEP_STACK: '1'
          DOCKER_BUILDKIT: '1'
          COMPOSE_DOCKER_CLI_BUILD: '1'
          E2E_SMOKE_TIMEOUT: '600'
        run: |
          start_epoch="$(date +%s)"
          make e2e-smoke-full \
            PYTHON=python \
            KEEP_STACK=1 \
            E2E_SMOKE_TIMEOUT="${E2E_SMOKE_TIMEOUT}" \
            E2E_COMPOSE_UP_FLAGS="-d --force-recreate --quiet-pull"
          end_epoch="$(date +%s)"
          echo "duration_seconds=$((end_epoch-start_epoch))" >> "$GITHUB_OUTPUT"

      - name: Capture dependency health snapshot (full profile)
        id: dependencies_health_full
        if: always()
        env:
          OUT_FILE: e2e-full-dependencies-health.json
          PROFILE_LABEL: Full Profile
        run: |
          python - <<'PY'
          import json
          import os
          import urllib.error
          import urllib.request

          out_file = os.environ["OUT_FILE"]
          profile_label = os.environ["PROFILE_LABEL"]
          url = "http://127.0.0.1:8000/health/dependencies"

          payload = None
          capture_error = None
          http_status = None
          try:
              with urllib.request.urlopen(url, timeout=8) as response:
                  http_status = response.getcode()
                  raw = response.read().decode("utf-8", errors="replace")
              payload = json.loads(raw) if raw else None
          except (urllib.error.URLError, TimeoutError, ValueError, json.JSONDecodeError) as exc:
              capture_error = str(exc)

          if not isinstance(payload, dict):
              payload = {
                  "status": "unavailable",
                  "error": capture_error or "Unable to parse dependency health response.",
              }
          if http_status is not None:
              payload.setdefault("http_status", http_status)
          if capture_error:
              payload.setdefault("capture_error", capture_error)

          with open(out_file, "w", encoding="utf-8") as handle:
              json.dump(payload, handle, indent=2, sort_keys=True)
              handle.write("\n")

          db_connected = payload.get("database", {}).get("connected")
          local_provider = payload.get("local_provider")
          local_provider_ready = (
              local_provider.get("ready")
              if isinstance(local_provider, dict)
              else None
          )
          local_provider_enabled = (
              local_provider.get("enabled")
              if isinstance(local_provider, dict)
              else None
          )
          local_provider_errors = []
          if isinstance(local_provider, dict):
              errors_value = local_provider.get("errors")
              if isinstance(errors_value, list):
                  local_provider_errors = [str(item) for item in errors_value]
              elif isinstance(errors_value, str) and errors_value.strip():
                  local_provider_errors = [errors_value.strip()]

          error_summary = "; ".join(local_provider_errors).replace("\n", " ").strip()

          with open(os.environ["GITHUB_OUTPUT"], "a", encoding="utf-8") as output:
              output.write(f"local_provider_ready={'true' if local_provider_ready is True else 'false'}\n")
              output.write(f"local_provider_enabled={'true' if local_provider_enabled is True else 'false'}\n")
              output.write(f"dependency_status={payload.get('status', 'unknown')}\n")
              output.write(f"local_provider_error_summary={error_summary}\n")

          with open(os.environ["GITHUB_STEP_SUMMARY"], "a", encoding="utf-8") as summary:
              summary.write(f"### Dependency Health Snapshot ({profile_label})\n")
              summary.write(f"- status: `{payload.get('status', 'unknown')}`\n")
              summary.write(f"- database.connected: `{db_connected}`\n")
              summary.write(f"- local_provider.enabled: `{local_provider_enabled}`\n")
              summary.write(f"- local_provider.ready: `{local_provider_ready}`\n")
          PY

      - name: Capture compose logs (full profile)
        if: always()
        run: |
          docker compose ps || true
          docker compose logs --no-color db chat web > e2e-full-compose.log || true

      - name: Capture e2e metrics (full profile)
        id: metrics_full
        if: always()
        run: |
          duration="${{ steps.run_smoke_full.outputs.duration_seconds }}"
          [ -z "$duration" ] && duration="unknown"
          chat_size="$(docker image inspect contoso-chat:latest --format '{{.Size}}' 2>/dev/null || echo 0)"
          web_size="$(docker image inspect contoso-web:latest --format '{{.Size}}' 2>/dev/null || echo 0)"
          max_duration=600
          max_chat_size=2000000000
          max_web_size=1500000000
          budget_failed=0
          warnings=()
          if [ "$duration" != "unknown" ] && [ "$duration" -gt "$max_duration" ]; then
            warnings+=("duration_above_budget")
            budget_failed=1
          fi
          if [ "$chat_size" -gt "$max_chat_size" ]; then
            warnings+=("chat_image_above_budget")
            budget_failed=1
          fi
          if [ "$web_size" -gt "$max_web_size" ]; then
            warnings+=("web_image_above_budget")
            budget_failed=1
          fi
          {
            echo "duration_seconds=$duration"
            echo "max_duration_seconds=$max_duration"
            echo "chat_image_bytes=$chat_size"
            echo "max_chat_image_bytes=$max_chat_size"
            echo "web_image_bytes=$web_size"
            echo "max_web_image_bytes=$max_web_size"
            for warning in "${warnings[@]}"; do
              echo "warning=$warning"
            done
          } | tee e2e-full-metrics.txt
          echo "budget_failed=$budget_failed" >> "$GITHUB_OUTPUT"

      - name: Analyze e2e metrics trend (full profile)
        id: analyze_metrics_full
        if: always()
        run: |
          mkdir -p .ci-metrics
          python scripts/ci_smoke_metrics.py \
            --profile full \
            --metrics-file e2e-full-metrics.txt \
            --history-file .ci-metrics/full-history.json \
            --summary-file e2e-full-metrics-summary.md \
            --run-id "${{ github.run_id }}" \
            --sha "${{ github.sha }}" \
            --status "${{ steps.run_smoke_full.outcome }}" \
            --budget-failed "${{ steps.metrics_full.outputs.budget_failed }}" \
            --github-output "$GITHUB_OUTPUT"
          cat e2e-full-metrics-summary.md >> "$GITHUB_STEP_SUMMARY"

      - name: Flag e2e regression signal (full profile)
        if: ${{ always() && steps.analyze_metrics_full.outputs.regression_detected == 'true' }}
        run: echo "::warning::E2E full profile regression signal detected vs previous successful baseline."

      - name: Enforce local-provider readiness (full profile)
        if: ${{ always() && steps.run_smoke_full.outcome == 'success' }}
        env:
          LOCAL_PROVIDER_READY: ${{ steps.dependencies_health_full.outputs.local_provider_ready }}
          LOCAL_PROVIDER_ENABLED: ${{ steps.dependencies_health_full.outputs.local_provider_enabled }}
          LOCAL_PROVIDER_ERROR_SUMMARY: ${{ steps.dependencies_health_full.outputs.local_provider_error_summary }}
        run: |
          if [ "${LOCAL_PROVIDER_READY}" != "true" ]; then
            echo "::error::Full-profile dependency health gate failed: local_provider.ready is not true."
            {
              echo "### Full-Profile Local Provider Gate Failed"
              echo ""
              echo "- local_provider.ready: \`${LOCAL_PROVIDER_READY}\`"
              echo "- local_provider.enabled: \`${LOCAL_PROVIDER_ENABLED}\`"
              if [ -n "${LOCAL_PROVIDER_ERROR_SUMMARY}" ]; then
                echo "- local_provider.errors: \`${LOCAL_PROVIDER_ERROR_SUMMARY}\`"
              fi
              echo ""
              echo "See artifact \`e2e-full-dependencies-health.json\` for full payload."
            } >> "$GITHUB_STEP_SUMMARY"
            exit 1
          fi

      - name: Compute alert state (full profile)
        id: alert_state_full
        if: ${{ always() }}
        env:
          RUN_OUTCOME: ${{ steps.run_smoke_full.outcome }}
          BUDGET_FAILED: ${{ steps.metrics_full.outputs.budget_failed }}
          REGRESSION_DETECTED: ${{ steps.analyze_metrics_full.outputs.regression_detected }}
        run: |
          alert_needed=false
          alert_key="none"
          classes=()
          if [ "${RUN_OUTCOME}" != "success" ]; then
            classes+=("smoke_failure")
          fi
          if [ "${BUDGET_FAILED}" = "1" ]; then
            classes+=("budget_failure")
          fi
          if [ "${REGRESSION_DETECTED}" = "true" ]; then
            classes+=("regression_signal")
          fi
          if [ "${#classes[@]}" -gt 0 ]; then
            alert_needed=true
            alert_key="$(IFS=+; echo "${classes[*]}")"
          fi
          run_url="${GITHUB_SERVER_URL}/${GITHUB_REPOSITORY}/actions/runs/${GITHUB_RUN_ID}"
          {
            echo "alert_needed=${alert_needed}"
            echo "alert_key=${alert_key}"
          } >> "$GITHUB_OUTPUT"
          {
            echo "# Full-Profile Smoke Alert State"
            echo
            echo "- Event: \`${{ github.event_name }}\`"
            echo "- Run outcome: \`${RUN_OUTCOME}\`"
            echo "- Budget failed: \`${BUDGET_FAILED}\`"
            echo "- Regression detected: \`${REGRESSION_DETECTED}\`"
            echo "- Alert needed: \`${alert_needed}\`"
            echo "- Alert key: \`${alert_key}\`"
            echo "- Run URL: ${run_url}"
          } > e2e-full-alert-state.md

      - name: Create or update issue for scheduled full-profile smoke alert
        if: ${{ always() && github.event_name == 'schedule' && steps.alert_state_full.outputs.alert_needed == 'true' }}
        uses: actions/github-script@v7
        env:
          RUN_OUTCOME: ${{ steps.run_smoke_full.outcome }}
          BUDGET_FAILED: ${{ steps.metrics_full.outputs.budget_failed }}
          REGRESSION_DETECTED: ${{ steps.analyze_metrics_full.outputs.regression_detected }}
          ALERT_KEY: ${{ steps.alert_state_full.outputs.alert_key }}
        with:
          script: |
            const fs = require('fs');
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const runId = context.runId;
            const runUrl = `${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/actions/runs/${runId}`;
            const title = `[CI] Full-profile smoke alert: ${process.env.ALERT_KEY}`;
            const updateBody = [
              'Latest scheduled full-profile smoke still reports an alert condition.',
              '',
              `- Run outcome: \`${process.env.RUN_OUTCOME}\``,
              `- Budget failed: \`${process.env.BUDGET_FAILED}\``,
              `- Regression detected: \`${process.env.REGRESSION_DETECTED}\``,
              `- Run URL: ${runUrl}`,
            ].join('\n');
            const prefix = '[CI] Full-profile smoke alert:';
            const issues = await github.paginate(github.rest.issues.listForRepo, {
              owner,
              repo,
              state: 'open',
              per_page: 100,
            });
            const openAlerts = issues.filter((issue) => !issue.pull_request && issue.title.startsWith(prefix));
            const staleAlerts = openAlerts.filter((issue) => issue.title !== title);
            for (const stale of staleAlerts) {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: stale.number,
                body: [
                  'Closing because scheduled alert classification changed to a new active class.',
                  '',
                  `- Latest run: ${runUrl}`,
                  `- Active alert key: \`${process.env.ALERT_KEY}\``,
                ].join('\n'),
              });
              await github.rest.issues.update({
                owner,
                repo,
                issue_number: stale.number,
                state: 'closed',
              });
            }

            const existing = openAlerts.find((issue) => issue.title === title);
            if (existing) {
              const issue = existing;
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: issue.number,
                body: updateBody,
              });
              fs.appendFileSync(
                'e2e-full-alert-state.md',
                [
                  '',
                  '## Alert Lifecycle',
                  `- Issue action: \`commented_existing\``,
                  `- Stale issues closed: ${staleAlerts.length}`,
                  `- Issue number: #${issue.number}`,
                  `- Issue URL: ${issue.html_url}`,
                ].join('\n') + '\n'
              );
              core.info(`Updated existing issue #${issue.number} for alert key ${process.env.ALERT_KEY}.`);
              return;
            }

            let summary = 'Summary file unavailable.';
            if (fs.existsSync('e2e-full-metrics-summary.md')) {
              summary = fs.readFileSync('e2e-full-metrics-summary.md', 'utf8');
            }

            const body = [
              'Scheduled full-profile smoke detected an alert condition.',
              '',
              `- Run outcome: \`${process.env.RUN_OUTCOME}\``,
              `- Budget failed: \`${process.env.BUDGET_FAILED}\``,
              `- Regression detected: \`${process.env.REGRESSION_DETECTED}\``,
              `- Run URL: ${runUrl}`,
              '',
              'Artifacts: `e2e-full-compose.log`, `e2e-full-metrics.txt`, `e2e-full-metrics-summary.md`, `e2e-full-dependencies-health.json`, `e2e-full-alert-state.md`.',
              '',
              '---',
              '',
              summary,
            ].join('\n');

            const created = await github.rest.issues.create({
              owner,
              repo,
              title,
              body,
            });
            fs.appendFileSync(
              'e2e-full-alert-state.md',
              [
                '',
                '## Alert Lifecycle',
                `- Issue action: \`created\``,
                `- Stale issues closed: ${staleAlerts.length}`,
                `- Issue number: #${created.data.number}`,
                `- Issue URL: ${created.data.html_url}`,
              ].join('\n') + '\n'
            );

      - name: Close scheduled full-profile smoke alert issues on recovery
        if: ${{ always() && github.event_name == 'schedule' && steps.alert_state_full.outputs.alert_needed != 'true' }}
        uses: actions/github-script@v7
        with:
          script: |
            const fs = require('fs');
            const owner = context.repo.owner;
            const repo = context.repo.repo;
            const runId = context.runId;
            const runUrl = `${process.env.GITHUB_SERVER_URL}/${process.env.GITHUB_REPOSITORY}/actions/runs/${runId}`;
            const prefix = '[CI] Full-profile smoke alert:';
            const issues = await github.paginate(github.rest.issues.listForRepo, {
              owner,
              repo,
              state: 'open',
              per_page: 100,
            });
            const openAlerts = issues.filter((issue) => !issue.pull_request && issue.title.startsWith(prefix));
            for (const issue of openAlerts) {
              await github.rest.issues.createComment({
                owner,
                repo,
                issue_number: issue.number,
                body: [
                  'Scheduled full-profile smoke recovered and no alert conditions were detected.',
                  '',
                  `- Recovery run: ${runUrl}`,
                ].join('\n'),
              });
              await github.rest.issues.update({
                owner,
                repo,
                issue_number: issue.number,
                state: 'closed',
              });
            }
            fs.appendFileSync(
              'e2e-full-alert-state.md',
              [
                '',
                '## Alert Lifecycle',
                `- Issue action: \`closed_on_recovery\``,
                `- Closed issue count: ${openAlerts.length}`,
              ].join('\n') + '\n'
            );

      - name: Publish alert lifecycle summary (full profile)
        if: always()
        run: |
          if [ -f e2e-full-alert-state.md ]; then
            cat e2e-full-alert-state.md >> "$GITHUB_STEP_SUMMARY"
          fi

      - name: Enforce e2e budgets (full profile)
        if: ${{ always() && steps.run_smoke_full.outcome == 'success' }}
        run: |
          if [ "${{ steps.metrics_full.outputs.budget_failed }}" = "1" ]; then
            echo "::error::Full-profile E2E smoke exceeded duration/image-size budget. See e2e-full-metrics.txt artifact."
            exit 1
          fi

      - name: Upload e2e logs (full profile)
        if: always()
        uses: actions/upload-artifact@v4
        with:
          name: e2e-full-compose-logs-${{ github.run_id }}
          path: |
            e2e-full-compose.log
            e2e-full-metrics.txt
            e2e-full-metrics-summary.md
            e2e-full-dependencies-health.json
            e2e-full-alert-state.md
            .ci-metrics/full-history.json
          if-no-files-found: warn

      - name: Save full metrics history cache
        if: always()
        uses: actions/cache/save@v4
        with:
          path: .ci-metrics
          key: e2e-metrics-full-${{ github.ref_name }}-${{ github.run_id }}-${{ github.run_attempt }}

      - name: Teardown e2e stack (full profile)
        if: always()
        run: docker compose down --volumes --remove-orphans

  onboarding-smoke:
    name: Onboarding Smoke
    needs: changes
    if: ${{ github.event_name != 'push' && needs.changes.outputs.runtime == 'true' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'
          cache-dependency-path: apps/web/package-lock.json

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Bootstrap and doctor
        env:
          TOOLCHAIN_CHECK_ALLOW_NON_MISE: '1'
          HUSKY: '0'
        run: make bootstrap PYTHON=python

  full-ci-main:
    name: Full CI (Main Branch)
    if: ${{ github.event_name == 'push' && github.ref == 'refs/heads/main' }}
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4
        with:
          fetch-depth: 0

      - name: Set up Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'
          cache: 'npm'
          cache-dependency-path: apps/web/package-lock.json

      - name: Set up Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.11'
          cache: 'pip'

      - name: Toolchain preflight
        run: TOOLCHAIN_CHECK_ALLOW_NON_MISE=1 make toolchain-doctor PYTHON=python

      - name: Install web dependencies
        env:
          HUSKY: '0'
        run: make -C apps/web setup

      - name: Install chat dependencies
        run: make -C services/chat setup

      - name: Generate Prisma Client (Python)
        run: prisma-client-py generate --schema=${{ github.workspace }}/apps/web/prisma/schema.prisma

      - name: Run full CI checks
        env:
          TOOLCHAIN_CHECK_ALLOW_NON_MISE: '1'
          HUSKY: '0'
          PROJECT_ID: local-project
          REGION: us-central1
        run: make ci PYTHON=python
